
\chapter{Antecedentes} % SOTA
\label{sec:related}

%\cleanchapterquote{A picture is worth a thousand words. An interface is worth a thousand pictures.}{Ben Shneiderman}{(Professor for Computer Science)}

%\begin{lstlisting}[language=Java, caption={A simple Hellow World example in %Java.}\label{lst:javahelloworld}]
%public class HelloWorld {
%	public static void main ( String[] args ) {
%		// Output Hello World!
%		System.out.println( "Hello World!" );
%	}
%}
%\end{lstlisting}

A continuación veremos los elementos esenciales de esta Tesis, es importante conocer la dificultad del problema para entender la relevancia del mismo. Los elementos claves se presentan en esta sección sin embargo existe un apéndice que ayude a comprender algunos términos que podrían ayudar al lector.


\section{Redes}

Una red es un conjunto de nodos unidos por aristas que representan relaciones. Los nodos y aristas los podemos encontrar en distintas disciplinas con distintos nombres, por ejemplo en física se denominan sitios y vínculos y en sociología actores y vínculos. 

La representación matemática de un red se denomina grafo y es estudiada en matemáticas discretas y más específicamente en teoría de grafos. Un grafo esta formalmente definido como $G = (V,E)$, donde $V$ es un conjunto de nodos (vertices) y $E$ aristas (edges). \cite{saoub_graph_2021}

 \begin{figure}[htbp]
   \centering
   \includesvg[width=0.2\textwidth]{figures/graph.svg}
    \caption{Graph}
    \label{fig:graph}
\end{figure}

Un grafo dirigido o dígrafo es un grafo en el que las aristas tienen sentidos. En el sentido más formal $G = (V,E,\phi)$ donde $\phi$ es una función de incidencia que asigna cada arista a un par ordenado de nodos. $ \phi :E \to \{(x,y)\mid (x,y)\in V^{2}\ \textrm{and } x \neq y \}$

 \begin{figure}[htbp]
   \centering
   \includesvg[width=0.2\textwidth]{figures/digraph.svg}
    \caption{Directed Graph (DiGraph)}
    \label{fig:graph}
\end{figure}

Un subgrafo de un grafo $G$ es otro grafo formado a partir de un subconjunto de nodos y aristas de $G$. El subconjunto de nodos debe incluir todos los extremos del subconjunto de aristas, pero también puede incluir nodos adicionales. Un subgrafo inducido es aquel que incluye todas las aristas cuyos puntos extremos pertenecen al subconjunto de nodos.

Un isomorfismo de grafos es una biyección de los nodos de un grafo sobre otro, de modo que se preserva la adyacencia de los nodos. Formalmente, el isomorfismo entre dos grafos $G$ y $H$ se define de la siguiente manera $f:V(G) \rightarrow V(H)$ donde $f$ preserva la relación de adyacencia.

 \begin{figure}[htbp]
   \centering
   \includesvg[width=0.8\textwidth]{figures/isomorphism.svg}
    \caption{Ejemplo de Isomorfismo entre $G$ y $H$}
    \label{fig:graph}
\end{figure}

Determinar si dos grafos con el mismo número de vértices $n$ y aristas $m$ son isomorfos o no, se conoce como el problema del isomorfismo de grafos. Se trata un problema no resuelto en computación y se considera un problema NP ya que no hay prueba de que sea NP-Completo. \cite{kobler_graph_1993} [Ver Apéndice] Este problema es un caso especial del problema de isomorfismo de subgrafos que esta probado es un problema NP-Completo. Resolver el problema de isomorphismo de grafos requeriría probar si las $n!$ biyecciones posibles preservan la adyacencia, sin embargo hasta ahora no se conoce un algoritmo general para resolver el problema. 


\section{Aprendizaje de Máquina}

El Aprendizaje de Máquina, en inglés Machine Learning (ML), es una rama de la Inteligencia Artificial que estudia algoritmos y técnicas que permitan automatizar soluciones a problemas complejos a partir del aprendizaje sobre conjuntos de datos en vez de los métodos convencionales de programación. 

A diferencia de la Inteligencia Artificial, que es un campo de estudio muy amplio y utiliza distintas técnicas para crear algoritmos inteligentes, el Aprendizaje de Máquina se centra principalmente en imitar el aprendizaje humano y gradualmente mejorar la precisión sobre una tarea. \cite{ibm_what_nodate} En la programación convencional dados ciertos requerimientos se diseña un programa que siga una serie de pasos para resolver un problema. No obstante en problemas complejos, a pesar tener requerimientos claros y específicos, este enfoque puede resultar complicado crear y programar un enorme conjunto de reglas para cumplir con la tarea, pensemos por ejemplo, en la tarea de detectar objetos en una imagen. \cite{rebala_introduction_2019}

Los algoritmos de Aprendizaje de Máquina son capaces de resolver problemas de una manera un tanto más genérica aprendiendo estructuras y reglas a partir de un conjunto de datos en vez de tener una estructura y diseño explicito. Por esta razón este tipo de algoritmos dependen directamente de la calidad y cantidad de ejemplos en el conjunto de datos. Estos ejemplos pueden tener etiquetas o ser datos crudos y dependiendo de la naturaleza del conjunto de datos encontraremos distintas categorías de algoritmos dentro del Aprendizaje de Máquina. \cite{rebala_introduction_2019}

Un conjunto de datos etiquetado es aquel cuyos ejemplos tienen la respuesta a la pregunta que se hace. Puede ser una etiqueta predeterminada sobre la clase que representan, por ejemplo, una imagen de un perro que contenga la etiqueta perro. Por otro lado los datos no etiquetados (crudos) son aquellas que no contienen la respuesta correcta a la pregunta en cuestión y que deben ser explorados. 

\subsection{Aprendizaje Supervisado}

El objetivo del Aprendizaje Supervisado es crear un modelo (una serie de reglas) sobre un conjunto de datos etiquetados para posteriormente poder predecir las etiquetas de datos que no se encuentran en el conjunto de datos. \cite{rebala_introduction_2019} En esta tarea los datos tienen una etiqueta predeterminada sobre la clase que  representan, por ejemplo, una imagen de un perro que contenga la etiqueta perro. 

Esta es la manera en la que estos algoritmos resuelven problemas, primero generan un modelo aprendiendo (con un entrenamiento) sobre un conjunto de datos con etiquetas conocidas y después ejecutando el modelo aprendido para predecir la etiqueta de datos nuevos, es decir que no se encontraban en el conjunto de datos de entrenamiento. Estos algoritmos tienden a ser mas efectivos que los modelos creados por humanos ya que pueden considerar mas atributos sobre un ejemplo y pueden procesar una cantidad superior de datos. \cite{rebala_introduction_2019}

Una de las tareas principales dentro del Aprendizaje Supervisado es la Clasificación, es decir, a partir de grupos previamente predeterminados hay que identificar el grupo al que pertenece un objeto dado.

\subsection{Aprendizaje No Supervisado}

En el Aprendizaje no Supervisado la tarea principal es aprender patrones a partir de conjuntos de datos no etiquetados. En el aprendizaje no supervisado la finalidad radica en descubrir propiedades útiles de los datos disponibles.

\paragraph{Agrupamientos}

La tarea quizás mas representativa de Aprendizaje No Supervisado es el \textit{Clustering} o Agrupamiento, se trata de dividir un gran conjunto de datos (puntos) de tal manera en que los puntos con propiedades o patrones en común se encuentren en un mismo grupo. La complejidad de esta tarea radica en que los grupos no se conocen previamente y la cantidad de los mismos es desconocida. Posteriormente lo resultados de esta tarea pueden ser utilizados como clasificadores o predictores de valores de atributos desconocidos, e incluso como herramientas de visualización. \cite{kubat_introduction_2017}

 \begin{figure}[htbp]
   \centering
   \includesvg[width=0.5\textwidth]{figures/cluster-example.svg}
    \caption{Un ejemplo de Clustering en $R^2$}
    \label{fig:clustering-example}
\end{figure}

Un ejemplo sencillo de agrupamiento en $R^2$ puede ser el de la Fig. \ref{fig:clustering-example}. Aquí cada punto representa un ejemplo descrito por dos atributos. En este caso es sencillo encontrar los agrupamientos a simple vista (ojímetro), sin embargo para cuatro dimensiones o mas, no es posible para los humanos visualizar los datos ni los grupos; estos casos solo pueden ser resueltos para los algoritmos de agrupamiento. \cite{kubat_introduction_2017}

Los algoritmos de agrupamiento frecuentemente requieren definir una función de distancia entre un ejemplo y el grupo. Dependiendo de la naturaleza de los atributos distintas medidas pueden ser propuestas; cuando se trata de puntos numéricos en el espacio comúnmente se utiliza la distancia Minkowski. $X = (x_1,x_2,\ldots,x_n)$ y $Y=(y_1,y_2,\ldots ,y_n) \in R^n$
 
$$D(X,Y) = (\sum_{i=1}^{n}|x_{i}-y_{i}|^{p})^{\frac{1}{p}}$$

Quizás uno de los algoritmos más conocidos de Agrupamiento es \textit{K-Means}. Este algoritmo agrupa los datos de entrada en $K$ grupos para una $K$ predefinida por el usuario. Como cada ejemplo no incluye una etiqueta de la clase o grupo al que pertenece se trata inherentemente de un algoritmo de Aprendizaje No Supervisado. La representación matemática de de los $K$ grupos se conoce como\textit{Centroide} Un centroide es el punto promedio de la distancia a cada punto del grupo que representa. La interpretación de cada grupo, representado por su centroide, puede ser que su valor promedio es la caracterización de todos los elementos del grupo.

 \begin{figure}[htbp]
   \centering
   \includesvg[width=0.8\textwidth]{figures/centroids-example.svg}
    \caption{Centroides}
    \label{fig:cengroides}
\end{figure}

Por lo tanto, el algoritmo de \textit{K-Means} busca minimzar la distancia promedio de cada Centroide a los puntos de su grupo. Los Centroides pueden ser inicializados de manera aleatoria o con algunas técnicas de inicialización que permitan al algoritmo converger más rápido. El algoritmo se itera recalculado los centroides y los puntos correspondientes hasta que ya no hay un cambio significativo o se ejecuta el número máximo de interaciones. Uno de los aspectos negativos de este algoritmo es que es muy susceptible a las condiciones iniciales y por lo tanto se recomienda ejecutar el algoritmo varias veces.

\lstinputlisting[language=Python, caption={Pseudocódigo $K-Means$ \cite{kubat_introduction_2017}}\label{algorithms:k-means}]{codes/kmeans.pseudo} 

\section{Métodos para agrupar redes}

\subsection{Embeddings}

\subsection{Propiedades de la Red}
\label{sec:related:sec2}

\subsection{Propiedades de los Nodos}
\label{sec:related:sec2}

\section{Interpretabilidad}
\label{sec:related:sec3}

A pesar de que los algoritmos de Aprendizaje de Máquina funcionan muy bien, muchas veces es difícil conocer las reglas que el algoritmo ha creado en el modelo aprendido y por lo tanto no es posible comprender como es que un problema esta siendo resuelto, a este problema se le conoce como el problema de interpretabilidad de un modelo. \cite{rebala_introduction_2019} 

Este problema esta especialmente presente en las Redes Neuronales que tienen millones de parámetros y por lo tanto es complicado interpretar las decisiones o la serie de reglas que llevan a cabo para resolver un problema. En algunas áreas es igual de importante la interpretabilidad del modelo que su precisión, un ejemplo claro es el de la medicina en donde los médicos deben ser capaces de interpretar y confirmar los resultados del diagnóstico de un algoritmo.

En el contexto de Twitter es igualmente importante interpretar los motivos por los que las redes son agrupadas.

Explicar que en el contexto de Twitter nos importa no sólo cómo quedan los grupos sino por qué. 
Redes sociales, lo que sociólogos han hecho con estas ideas
(como en la parte de antecedentes del paper)